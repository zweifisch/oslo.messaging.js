// Generated by CoffeeScript 1.8.0
(function() {
  var Connection, RpcServer, crypto, kwfn;

  crypto = require('crypto');

  kwfn = require('keyword-arguments');

  Connection = require('./Connection');

  RpcServer = (function() {
    function RpcServer(_arg) {
      this.url = _arg.url, this.exchange = _arg.exchange, this.topic = _arg.topic, this.version = _arg.version, this.timeout = _arg.timeout, this.ttl = _arg.ttl, this.noAck = _arg.noAck, this.delay = _arg.delay, this.maxRetry = _arg.maxRetry;
      this.consumers = {};
      this.ttl || (this.ttl = 60000);
      this.delay || (this.delay = 1000);
      this.maxRetry || (this.maxRetry = 3);
      this.replayQ = "reply_" + (crypto.randomBytes(16).toString('hex'));
      this.connection = new Connection({
        delay: this.delay,
        urls: this.url,
        maxRetry: this.maxRetry
      });
    }

    RpcServer.prototype.on = function(namespace, method, callback) {
      return this.connection.connect().then((function(_this) {
        return function() {
          var key;
          if (!_this.fanoutQ) {
            _this.fanoutQ = "fanout_" + (crypto.randomBytes(16).toString('hex'));
            _this.channel.assertQueue(_this.fanoutQ, {
              autoDelete: true,
              durable: false
            });
            _this.channel.bindQueue(_this.fanoutQ, _this.exchange, '#');
            _this.channel.consume(_this.fanoutQ, function(msg) {
              var args, content, decoded, key, _i, _len, _ref, _results;
              decoded = JSON.parse(msg.content.toString());
              content = JSON.parse(decoded['oslo.message']);
              if (content.ending) {
                return;
              }
              namespace = content.namespace, method = content.method, args = content.args;
              if (!(method && args)) {
                return;
              }
              key = namespace ? "" + namespace + ":" + method : method;
              if (key in _this.consumers) {
                _ref = _this.consumers[key];
                _results = [];
                for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                  callback = _ref[_i];
                  _results.push(callback(args));
                }
                return _results;
              }
            });
          }
          key = "" + namespace + ":" + method;
          if (key in _this.consumers) {
            _this.consumers[key].push(kwfn(callback));
          } else {
            _this.consumers[key] = [kwfn(callback)];
          }
          return _this;
        };
      })(this));
    };

    return RpcServer;

  })();

  module.exports = RpcServer;

}).call(this);
