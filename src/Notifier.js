// Generated by CoffeeScript 1.7.1
(function() {
  var Notifier, crypto, getConnectionPool, log, promise;

  crypto = require('crypto');

  promise = require('when').promise;

  log = require('./logger')('notifier');

  getConnectionPool = require('./ConnectionPool').getConnectionPool;

  Notifier = (function() {
    function Notifier(_arg) {
      this.url = _arg.url, this.prefix = _arg.prefix, this.topic = _arg.topic, this.exchange = _arg.exchange, this.delay = _arg.delay, this.noAck = _arg.noAck;
      if (this.delay == null) {
        this.delay = 1000;
      }
      this.queue = "" + (this.prefix || 'notifier') + "_" + (crypto.randomBytes(16).toString('hex'));
      log.debug("queue: " + this.queue);
    }

    Notifier.prototype.connect = function() {
      if (!this.q) {
        this.q = promise((function(_this) {
          return function(resolve, reject) {
            return (getConnectionPool(_this.delay)).connect(_this.url, function(connection) {
              return connection.createChannel().then(function(channel) {
                var consumeQ, consumer;
                _this.channel = channel;
                _this.channel.assertExchange(_this.exchange, 'topic', {
                  autoDelete: false,
                  durable: false
                }).then(function() {
                  return log.info("exchange " + _this.exchange + " asserted");
                }).then(null, function(error) {
                  return log.error(error);
                });
                _this.channel.assertQueue(_this.queue, {
                  autoDelete: true,
                  durable: false
                }).then(function() {
                  return log.info("queue " + _this.queue + " asserted");
                }).then(null, function(error) {
                  return log.error(error);
                });
                _this.channel.bindQueue(_this.queue, _this.exchange, _this.topic).then(function() {
                  return log.info("topic " + _this.topic + " binded");
                }).then(null, function(error) {
                  return log.error(error);
                });
                consumer = function(msg) {
                  var decoded;
                  decoded = JSON.parse(msg.content.toString());
                  log.debug(decoded);
                  if (_this.noAck) {
                    return _this.callback(decoded);
                  } else {
                    return _this.callback(decoded, function() {
                      return _this.channel.ack(msg);
                    });
                  }
                };
                consumeQ = _this.channel.consume(_this.queue, consumer, {
                  noAck: _this.noAck
                });
                consumeQ.then(function() {
                  log.info("wait for notification on queue " + _this.queue);
                  return resolve(_this);
                });
                return consumeQ.then(null, function(error) {
                  return reject(error);
                });
              });
            });
          };
        })(this));
      }
      return this.q;
    };

    Notifier.prototype.onMessage = function(callback) {
      return this.callback = callback;
    };

    return Notifier;

  })();

  module.exports = Notifier;

}).call(this);
