// Generated by CoffeeScript 1.9.2
(function() {
  var Connection, EventEmitter, amqp, connections, log, sanitize,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  EventEmitter = require('events').EventEmitter;

  amqp = require('amqplib');

  log = require('./logger')('connection');

  sanitize = function(url) {
    return url.replace(/\/\/[^@]*@/, '//<sanitized>@');
  };

  Connection = (function(superClass) {
    extend(Connection, superClass);

    function Connection(arg) {
      var urls;
      this.retryDelay = arg.retryDelay, urls = arg.urls, this.maxRetry = arg.maxRetry, this.timeout = arg.timeout;
      this.reconnect = bind(this.reconnect, this);
      if ('string' !== typeof urls) {
        throw new Error("urls must be string");
      }
      if (!urls.length) {
        throw new Error("urls is empty");
      }
      this.urls = urls.split(';');
      this.callbacks = [];
      this.urlIndex = 0;
      this.retried = 0;
      log.debug("urls " + urls);
      log.debug("maxRetry " + this.maxRetry);
    }

    Connection.prototype.connect = function(callback) {
      this.callbacks.push(callback);
      if (this.connectionPromise) {
        log.debug('connection available');
      }
      if (!this.connectionPromise) {
        this.connectionPromise = this._connect(this.getCurrentUrl());
      }
      return this.connectionPromise.then(callback);
    };

    Connection.prototype._connect = function(url) {
      var q, sanitizedUrl;
      log.debug("connecting url " + url);
      sanitizedUrl = sanitize(url);
      this.emit('connecting', {
        url: sanitizedUrl
      });
      q = amqp.connect(url, {
        timeout: this.timeout
      });
      q.then((function(_this) {
        return function(connection) {
          connection.on('error', function(error) {
            log.error(error);
            _this.emit('error', error);
            return setTimeout(_this.reconnect, _this.retryDelay);
          });
          log.info(sanitizedUrl + " connected");
          return _this.emit('connected', sanitizedUrl);
        };
      })(this));
      q.then(null, (function(_this) {
        return function(error) {
          log.error(error);
          _this.emit('error', error);
          return setTimeout(_this.reconnect, _this.retryDelay);
        };
      })(this));
      return q;
    };

    Connection.prototype.reconnect = function() {
      var url;
      this.retried += 1;
      log.debug("retry " + this.retried);
      if (this.retried > this.maxRetry) {
        this.retried = 0;
        url = this.getNextUrl();
      } else {
        url = this.getCurrentUrl();
      }
      this.connectionPromise = this._connect(url);
      return this.connectionPromise.then((function(_this) {
        return function(connection) {
          var callback, i, len, ref, results;
          ref = _this.callbacks;
          results = [];
          for (i = 0, len = ref.length; i < len; i++) {
            callback = ref[i];
            results.push(callback(connection));
          }
          return results;
        };
      })(this));
    };

    Connection.prototype.getNextUrl = function() {
      this.urlIndex += 1;
      if (this.urlIndex >= this.urls.length) {
        this.urlIndex -= this.urls.length;
      }
      log.debug("get next url " + this.urls[this.urlIndex]);
      return this.urls[this.urlIndex];
    };

    Connection.prototype.getCurrentUrl = function() {
      log.debug("current url " + this.urls[this.urlIndex]);
      return this.urls[this.urlIndex];
    };

    return Connection;

  })(EventEmitter);

  connections = {};

  Connection.getConnection = function(arg) {
    var maxRetry, retryDelay, timeout, urls;
    urls = arg.urls, retryDelay = arg.retryDelay, maxRetry = arg.maxRetry, timeout = arg.timeout;
    if (!connections[urls]) {
      connections[urls] = new Connection({
        urls: urls,
        retryDelay: retryDelay,
        maxRetry: maxRetry,
        timeout: timeout
      });
    }
    return connections[urls];
  };

  module.exports = Connection;

}).call(this);
