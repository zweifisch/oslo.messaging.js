// Generated by CoffeeScript 1.8.0
(function() {
  var RpcClient, crypto, getConnectionPool, kwfn, log, promise, signal,
    __hasProp = {}.hasOwnProperty;

  crypto = require('crypto');

  kwfn = require('keyword-arguments');

  signal = require('too-late')();

  promise = require('when').promise;

  log = require('./logger')('rpcclient');

  getConnectionPool = require('./ConnectionPool').getConnectionPool;

  RpcClient = (function() {
    function RpcClient(_arg) {
      this.url = _arg.url, this.exchange = _arg.exchange, this.topic = _arg.topic, this.version = _arg.version, this.timeout = _arg.timeout, this.ttl = _arg.ttl, this.noAck = _arg.noAck, this.delay = _arg.delay, this.messageTtl = _arg.messageTtl;
      this.consumers = {};
      this.ttl || (this.ttl = 60000);
      this.delay || (this.delay = 1000);
      this.replyQ = "reply_" + (crypto.randomBytes(16).toString('hex'));
      log.debug("queue: " + this.replyQ);
    }

    RpcClient.prototype.connect = function() {
      if (!this.q) {
        this.q = promise((function(_this) {
          return function(resolve, reject) {
            return (getConnectionPool(_this.delay)).connect(_this.url, function(connection) {
              return connection.createChannel().then(function(channel) {
                var onMsg;
                _this.channel = channel;
                _this.channel.assertExchange(_this.replyQ, 'direct', {
                  autoDelete: true,
                  durable: false
                });
                _this.channel.assertQueue(_this.replyQ, {
                  autoDelete: true,
                  durable: false,
                  messageTtl: _this.messageTtl
                });
                _this.channel.bindQueue(_this.replyQ, _this.replyQ, _this.replyQ);
                onMsg = function(msg) {
                  var content, decoded;
                  decoded = JSON.parse(msg.content.toString());
                  content = JSON.parse(decoded['oslo.message']);
                  if (content.ending) {
                    return;
                  }
                  return signal.deliver(content._msg_id, content);
                };
                return _this.channel.consume(_this.replyQ, onMsg, {
                  noAck: _this.noAck
                }).then(function() {
                  log.info("wait for result on queue " + _this.replyQ);
                  return resolve(_this);
                }).then(null, function(error) {
                  return reject(error);
                });
              }).then(null, function(error) {
                return reject(error);
              });
            });
          };
        })(this));
      }
      return this.q;
    };

    RpcClient.prototype.call = function(namespace, context, method, args) {
      log.debug(namespace, context, method, args);
      return promise((function(_this) {
        return function(resolve, reject) {
          return _this.connect().then(function() {
            var key, msgId, payload, value;
            msgId = crypto.randomBytes(16).toString('hex');
            payload = {
              _msg_id: msgId,
              _reply_q: _this.replyQ,
              _unique_id: crypto.randomBytes(16).toString('hex'),
              args: args,
              method: method,
              version: _this.version
            };
            log.debug(msgId, payload);
            if (namespace) {
              payload.namespace = namespace;
            }
            if (context) {
              for (key in context) {
                if (!__hasProp.call(context, key)) continue;
                value = context[key];
                payload["_context_" + key] = value;
              }
            }
            payload = new Buffer(JSON.stringify({
              'oslo.message': JSON.stringify(payload),
              'oslo.version': '2.0'
            }));
            _this.channel.publish(_this.exchange, _this.topic, payload, {
              contentEncoding: 'utf-8',
              contentType: 'application/json',
              headers: {
                ttl: _this.ttl
              },
              priority: 0,
              deliveryMode: 2
            });
            return (function(msgId, reject, resolve) {
              return signal.waitfor(msgId, function(data) {
                if (data.failure) {
                  return reject(JSON.parse(data.failure));
                } else {
                  return resolve(data.result);
                }
              }).till(_this.timeout, function() {
                return reject({
                  message: 'timeout',
                  message_id: msgId
                });
              });
            })(msgId, reject, resolve);
          }).then(null, function(error) {
            return reject(error);
          });
        };
      })(this));
    };

    RpcClient.prototype.cast = function(namespace, context, method, args) {
      return this.connect().then((function(_this) {
        return function() {
          var key, msgId, payload, value;
          msgId = crypto.randomBytes(16).toString('hex');
          payload = {
            _msg_id: msgId,
            _unique_id: crypto.randomBytes(16).toString('hex'),
            args: args,
            method: method,
            version: _this.version
          };
          if (namespace) {
            payload.namespace = namespace;
          }
          if (context) {
            for (key in context) {
              if (!__hasProp.call(context, key)) continue;
              value = context[key];
              payload["_context_" + key] = value;
            }
          }
          payload = new Buffer(JSON.stringify({
            'oslo.message': JSON.stringify(payload),
            'oslo.version': '2.0'
          }));
          return _this.channel.publish(_this.exchange, '#', payload, {
            contentEncoding: 'utf-8',
            contentType: 'application/json',
            headers: {
              ttl: _this.ttl
            },
            priority: 0,
            deliveryMode: 2
          });
        };
      })(this));
    };

    return RpcClient;

  })();

  module.exports = RpcClient;

}).call(this);
