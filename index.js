// Generated by CoffeeScript 1.7.1
(function() {
  var Client, Promise, amqp, crypto, signal,
    __hasProp = {}.hasOwnProperty;

  amqp = require('amqplib');

  crypto = require('crypto');

  Promise = require('promise');

  signal = require('too-late')();

  Client = (function() {
    function Client(_arg) {
      this.url = _arg.url, this.exchange = _arg.exchange, this.topic = _arg.topic, this.version = _arg.version, this.timeout = _arg.timeout, this.ttl = _arg.ttl;
      this.ttl || (this.ttl = 60000);
    }

    Client.prototype.connect = function() {
      if (this.connectP) {
        return this.connectP;
      }
      return this.connectP = new Promise((function(_this) {
        return function(resolve, reject) {
          return amqp.connect(_this.url).then(function(connection) {
            return connection.createChannel().then(function(channel) {
              var onMsg;
              _this.channel = channel;
              _this.replayQ = "reply_" + (crypto.randomBytes(16).toString('hex'));
              _this.channel.assertExchange(_this.replayQ, 'direct', {
                autoDelete: true,
                durable: false
              });
              _this.channel.assertQueue(_this.replayQ, {
                autoDelete: true,
                durable: false
              });
              _this.channel.bindQueue(_this.replayQ, _this.replayQ, _this.replayQ);
              onMsg = function(msg) {
                var content, decoded;
                decoded = JSON.parse(msg.content.toString());
                content = JSON.parse(decoded['oslo.message']);
                if (content.ending) {
                  return;
                }
                return signal.deliver(content._msg_id, content);
              };
              return _this.channel.consume(_this.replayQ, onMsg).then(function() {
                return resolve(_this);
              }).then(null, function(err) {
                return reject(err);
              });
            }).then(null, function(err) {
              return reject(err);
            });
          }).then(null, function(err) {
            return reject(err);
          });
        };
      })(this));
    };

    Client.prototype.call = function(namespace, context, method, args) {
      return new Promise((function(_this) {
        return function(resolve, reject) {
          return _this.connect().then(function() {
            var key, msgId, payload, value;
            msgId = crypto.randomBytes(16).toString('hex');
            payload = {
              _msg_id: msgId,
              _reply_q: _this.replayQ,
              _unique_id: crypto.randomBytes(16).toString('hex'),
              args: args,
              method: method,
              namespace: namespace,
              version: _this.version
            };
            if (context) {
              for (key in context) {
                if (!__hasProp.call(context, key)) continue;
                value = context[key];
                payload["_context_" + key] = value;
              }
            }
            payload = new Buffer(JSON.stringify({
              'oslo.message': JSON.stringify(payload),
              'oslo.version': '2.0'
            }));
            _this.channel.publish(_this.exchange, _this.topic, payload, {
              contentEncoding: 'utf-8',
              contentType: 'application/json',
              headers: {
                ttl: _this.ttl
              },
              priority: 0,
              deliveryMode: 2
            });
            return (function(msgId, reject, resolve) {
              return signal.waitfor(msgId, function(data) {
                if (data.failure) {
                  return reject(JSON.parse(data.failure));
                } else {
                  return resolve(data.result);
                }
              }).till(_this.timeout, function() {
                return reject({
                  message: 'timeout',
                  message_id: msgId
                });
              });
            })(msgId, reject, resolve);
          }).then(null, function(err) {
            return reject(err);
          });
        };
      })(this));
    };

    return Client;

  })();

  module.exports = Client;

}).call(this);
